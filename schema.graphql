type Project @entity {
  id: ID!
  index: BigInt! # BigInt equivalent of ID for sorting
  active: Boolean!
  additionalPayee: Bytes
  additionalPayeePercentage: BigInt
  artist: Account!
  artistAddress: Bytes!
  artistName: String
  baseIpfsUri: String
  baseUri: String
  complete: Boolean!
  curationStatus: String
  currencyAddress: Bytes
  currencySymbol: String
  description: String
  dynamic: Boolean!
  invocations: BigInt!
  ipfsHash: String
  license: String
  locked: Boolean!
  maxInvocations: BigInt!
  name: String
  paused: Boolean!
  pricePerTokenInWei: BigInt!
  royaltyPercentage: BigInt
  script: String
  scriptCount: BigInt!
  scriptJSON: String
  tokens: [Token!] @derivedFrom(field: "project")
  useHashString: Boolean!
  useIpfs: Boolean
  website: String
  osTotalVolumeInWei: BigInt!
  "Accounts that own tokens from the project"
  owners: [AccountProject!] @derivedFrom(field: "project")
  createdAt: BigInt!
  updatedAt: BigInt!
  scriptUpdatedAt: BigInt
  contract: Contract!
}

type Contract @entity {
  id: ID!
  admin: Bytes!
  artblocksAddress: Bytes!
  artblocksPercentage: BigInt!
  mintWhitelisted: [Bytes!]!
  randomizerContract: Bytes
  nextProjectId: BigInt!
  projects: [Project!] @derivedFrom(field: "contract")
  whitelisted: [Whitelisting!] @derivedFrom(field: "contract")
}

type Whitelisting @entity {
  id: ID!
  account: Account!
  contract: Contract!
}

type Account @entity {
  id: ID!
  tokens: [Token!] @derivedFrom(field: "owner")
  "Projects the account owns tokens from"
  projectsOwned: [AccountProject!] @derivedFrom(field: "account")
  projectsCreated: [Project!] @derivedFrom(field: "artist")
  whitelistedOn: [Whitelisting!] @derivedFrom(field: "account")
}

type AccountProject @entity {
  id: ID!
  account: Account!
  project: Project!
  count: Int!
}

type Token @entity {
  id: ID!
  invocation: BigInt!
  hash: Bytes!
  owner: Account!
  project: Project!
  uri: String
  createdAt: BigInt!
  updatedAt: BigInt!
  transactionHash: Bytes!

  "Token <=> OpenSeaSale lookup table to get the OpenSea Sale history"
  tokenOpenSeaSaleLookupTable: [TokenOpenSeaSaleLookupTable!]! @derivedFrom(field: "token")
}

enum SaleType {
  Single,
  Bundle
}

type OpenSeaSale @entity {
  "The transaction hash when the OpenSea sale occured"
  id: ID!

  "The sale type (Single | Bundle)"
  saleType: SaleType

  "The block number of the OpenSea sale"
  blockNumber: BigInt!

  "The timestamp of the OpenSea sale"
  blockTimestamp: BigInt!

  "A raw formated string of the token(s) sold (i.e TokenID1::TokenID2::TokenID3)"
  summaryTokensSold: String!

  "Token to OpenSeaSale lookup table to get the list of Nfts sold in this sale"
  tokenOpenSeaSaleLookupTable: [TokenOpenSeaSaleLookupTable!]! @derivedFrom(field: "openSeaSale")

  "The seller address"
  seller: Bytes!

  "The buyer address"
  buyer: Bytes!

  "The ERC20 token used for the payement"
  paymentToken: Bytes!

  "The price of the OpenSea sale"
  price: BigInt!
}

type TokenOpenSeaSaleLookupTable @entity {
  "Set to `Token Id <=> OpenSeaSale Id"
  id: ID!

  "The token sold"
  token: Token!

  "The associated OpenSea sale"
  openSeaSale: OpenSeaSale!
}