type Project @entity {
  "Unique identifier made up of contract address and project id"
  id: ID!

  "ID of the project on the contract"
  projectId: BigInt!

  "Determines if the project should be visible to the public"
  active: Boolean!

  "Address to split sales with the artist"
  additionalPayee: Bytes

  "Percentage of sales that goes to additional payee"
  additionalPayeePercentage: BigInt

  "Artist that created the project"
  artist: Account!

  "Wallet address of the artist"
  artistAddress: Bytes!

  "Artist name"
  artistName: String

  baseIpfsUri: String
  baseUri: String

  "A project is complete when it has reached its maximum invocations"
  complete: Boolean!

  "Curated, playground, factory. A project with no curation status is considered factory"
  curationStatus: String

  "ERC-20 contract address if the project is purchasable via ERC-20"
  currencyAddress: Bytes

  "Currency symbol for ERC-20"
  currencySymbol: String

  "Artist description of the project"
  description: String

  "Is the project dynamic or a static image"
  dynamic: Boolean!

  "Number of times the project has been invoked - number of tokens of the project"
  invocations: BigInt!

  ipfsHash: String

  "License for the project"
  license: String

  "Once the project is locked its script may never be updated again"
  locked: Boolean!

  "Maximum number of invocations allowed for the project"
  maxInvocations: BigInt!

  "Project name"
  name: String

  "Purchases paused"
  paused: Boolean!

  pricePerTokenInWei: BigInt!

  "Artist/additional payee royalty percentage"
  royaltyPercentage: BigInt

  "The full script composed of scripts"
  script: String

  "Parts of the project script"
  scripts: [ProjectScript!] @derivedFrom(field: "project")

  "The number of scripts stored on-chain"
  scriptCount: BigInt!

  "The number of external asset dependencies stored on-chain"
  externalAssetDependencyCount: BigInt!

  "Extra information about the script and rendering options"
  scriptJSON: String

  "Tokens of the project"
  tokens: [Token!] @derivedFrom(field: "project")

  "Does the project actually use the hash string"
  useHashString: Boolean!

  "Does the project use media from ipfs"
  useIpfs: Boolean

  "Artist or project website"
  website: String

  "Accounts that own tokens of the project"
  owners: [AccountProject!] @derivedFrom(field: "project")

  createdAt: BigInt!
  updatedAt: BigInt!
  activatedAt: BigInt
  scriptUpdatedAt: BigInt
  contract: Contract!

  "Minter configuration for this project (not implemented prior to minter filters)"
  minterConfiguration: ProjectMinterConfiguration

  "Lookup table to get the Sale history of the project"
  saleLookupTables: [SaleLookupTable!]! @derivedFrom(field: "project")

  externalAssetDependencies: [ProjectExternalAssetDependency!]! @derivedFrom(field: "project")
}

type ProjectScript @entity {
  id: ID!
  index: BigInt!
  project: Project!
  script: String!
}

type Contract @entity {
  id: ID!
  admin: Bytes!

  "Address that receives platform fees"
  renderProviderAddress: Bytes!

  "Percentage of sales the platform takes"
  renderProviderPercentage: BigInt!

  "List of contracts that are allowed to mint"
  mintWhitelisted: [Bytes!]!

  "Randomizer contract used to generate token hashes"
  randomizerContract: Bytes

  nextProjectId: BigInt!

  "List of projects on the contract"
  projects: [Project!] @derivedFrom(field: "contract")

  "List of tokens on the contract"
  tokens: [Token!] @derivedFrom(field: "contract")

  "Accounts whitelisted on the contract"
  whitelisted: [Whitelisting!] @derivedFrom(field: "contract")

  createdAt: BigInt!

  updatedAt: BigInt!

  "Associated minter filter (if applicable)"
  minterFilter: MinterFilter
}

type Whitelisting @entity {
  id: ID!
  account: Account!
  contract: Contract!
}

type Account @entity {
  id: ID!
  tokens: [Token!] @derivedFrom(field: "owner")

  "Projects the account owns tokens from"
  projectsOwned: [AccountProject!] @derivedFrom(field: "account")

  "Projects the account is listed as artist for"
  projectsCreated: [Project!] @derivedFrom(field: "artist")

  "Contracts the account is whitelisted on"
  whitelistedOn: [Whitelisting!] @derivedFrom(field: "account")
}

type AccountProject @entity {
  id: ID!
  account: Account!
  project: Project!
  count: Int!
}

type Token @entity {
  "Unique identifier made up of contract address and token id"
  id: ID!

  "ID of the token on the contract"
  tokenId: BigInt!

  "Contract the token is on"
  contract: Contract!

  "Invocation number of the project"
  invocation: BigInt!

  "Unique string used as input to the tokens project script"
  hash: Bytes!

  "Current owner of the token"
  owner: Account!

  "Project of the token"
  project: Project!

  uri: String
  createdAt: BigInt!
  updatedAt: BigInt!

  "Transaction hash of token mint"
  transactionHash: Bytes!

  transfers: [Transfer!] @derivedFrom(field: "token")

  "Lookup table to get the Sale history"
  saleLookupTables: [SaleLookupTable!]! @derivedFrom(field: "token")

  "Next available sale id"
  nextSaleId: BigInt!
}

type MinterFilter @entity {
  "Unique identifier made up of minter filter contract address"
  id: ID!

  "Associated core contract"
  coreContract: Contract!

  "Minters allowlisted on MinterFilter"
  minterAllowlist: [Minter!]!

  "Minters associated with MinterFilter"
  associatedMinters: [Minter!]! @derivedFrom(field: "minterFilter")

  updatedAt: BigInt!
}

enum MinterType {
  MinterSetPriceV0
  MinterSetPriceERC20V0
  MinterDALinV0
  MinterDAExpV0
  MinterSetPriceV1
  MinterSetPriceERC20V1
  MinterDALinV1
  MinterDAExpV1
  MinterHolderV0
  MinterMerkleV0
}

type Minter @entity {
  "Unique identifier made up of minter contract address"
  id: ID!

  "Minter type"
  type: MinterType!

  "Associated Minter Filter"
  minterFilter: MinterFilter!

  "Minimum allowed auction length in seconds (linear Dutch auction minters)"
  minimumAuctionLengthInSeconds: BigInt

  "Minimum allowed half life in seconds (exponential Dutch auction minters)"
  minimumHalfLifeInSeconds: BigInt

  "Maximum allowed half life in seconds (exponential Dutch auction minters)"
  maximumHalfLifeInSeconds: BigInt

  "Configuration details used by specific minters (json string)"
  extraMinterDetails: String!

  coreContract: Contract!

  updatedAt: BigInt!
}

type ProjectMinterConfiguration @entity {
  "Unique identifier made up of minter contract address-projectId"
  id: ID!

  "The associated project"
  project: Project!

  "The associated minter"
  minter: Minter!

  "true if project's token price has been configured on minter"
  priceIsConfigured: Boolean!

  "currency symbol as defined on minter - ETH reserved for ether"
  currencySymbol: String!

  "currency address as defined on minter - address(0) reserved for ether"
  currencyAddress: Bytes!

  "Defines if purchasing token to another is allowed"
  purchaseToDisabled: Boolean!

  "price of token or resting price of Duch auction, in wei"
  basePrice: BigInt

  "Dutch auction start price, in wei"
  startPrice: BigInt

  "Half life for exponential decay Dutch auction, in seconds"
  halfLifeSeconds: BigInt

  "Dutch auction start time (unix timestamp)"
  startTime: BigInt

  "Linear Dutch auction end time (unix timestamp)"
  endTime: BigInt

  "Configuration details used by specific minter project configurations (json string)"
  extraMinterDetails: String!
}

enum SaleType {
  Single
  Bundle
}

enum PaymentType {
  Native
  ERC20
  ERC721
  ERC1155
}

enum Exchange {
  "Opensea V1"
  OS_V1
  "Opensea V2"
  OS_V2
  "LooksRare"
  LR_V1
  "Opensea Seaport"
  OS_SP
}

type Payment @entity {
  "Payment id formatted: '{SaleId}-{paymentNumber}' (paymentNumber will be 0 for non-Seaport trades)"
  id: ID!

  "Type of token transferred in this payment"
  paymentType: PaymentType!

  "The address of the token used for the payment"
  paymentToken: Bytes!

  "The price of the sale"
  price: BigInt!

  "The associated sale"
  sale: Sale!

  "The recipient address"
  recipient: Bytes!
}

type Sale @entity {
  "The sale id formated: tokenId - token.nextSaleId (using first token sold for bundles) for Opensea V1/V2, orderHash from sale event for Looksrare and Seaport"
  id: ID!

  "The hash of the transaction"
  txHash: Bytes!

  "The exchange used for this sale"
  exchange: Exchange!

  "The sale type (Single | Bundle)"
  saleType: SaleType!

  "The block number of the sale"
  blockNumber: BigInt!

  "The timestamp of the sale"
  blockTimestamp: BigInt!

  "A raw formated string of the token(s) sold (i.e TokenID1::TokenID2::TokenID3)"
  summaryTokensSold: String!

  "Lookup table to get the list of Tokens sold in this sale"
  saleLookupTables: [SaleLookupTable!]! @derivedFrom(field: "sale")

  "The seller address"
  seller: Bytes!

  "The buyer address"
  buyer: Bytes!

  "List of Payment tokens involved in this sale"
  payments: [Payment!]! @derivedFrom(field: "sale")

  "Private sales are flagged by this boolean"
  isPrivate: Boolean!
}

type SaleLookupTable @entity {
  "Set to `Project Id::Token Id::Sale Id"
  id: ID!

  "The block number of the sale"
  blockNumber: BigInt!

  "Timestamp of the sale"
  timestamp: BigInt!

  "The associated project"
  project: Project!

  "The token sold"
  token: Token!

  "The associated sale"
  sale: Sale!
}

type Transfer @entity(immutable: true) {
  id: ID!

  transactionHash: Bytes!

  token: Token!

  createdAt: BigInt!

  to: Bytes!

  from: Bytes!
}

enum ProjectExternalAssetDependencyType {
  "Asset hosted on IPFS"
  IPFS
  "Asset hosted on Arweave"
  ARWEAVE
}
type ProjectExternalAssetDependency @entity {
  "Unique identifier made up of projectId-cid"
  id: ID!

  "The associated project"
  project: Project!

  "The dependency type"
  dependencyType: ProjectExternalAssetDependencyType!

  "The dependency cid"
  cid: String!

  "The dependency index"
  index: BigInt!
}
