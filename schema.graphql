type Project @entity {
  id: ID!
  index: BigInt! # BigInt equivalent of ID for sorting
  active: Boolean!
  additionalPayee: Bytes
  additionalPayeePercentage: BigInt
  artist: Account!
  artistAddress: Bytes!
  artistName: String
  baseIpfsUri: String
  baseUri: String
  complete: Boolean!
  curationStatus: String
  currencyAddress: Bytes
  currencySymbol: String
  description: String
  dynamic: Boolean!
  invocations: BigInt!
  ipfsHash: String
  license: String
  locked: Boolean!
  maxInvocations: BigInt!
  name: String
  paused: Boolean!
  pricePerTokenInWei: BigInt!
  royaltyPercentage: BigInt
  script: String
  scriptCount: BigInt!
  scriptJSON: String
  tokens: [Token!] @derivedFrom(field: "project")
  useHashString: Boolean!
  useIpfs: Boolean
  website: String
  osTotalVolumeInWei: BigInt!
  "Accounts that own tokens from the project"
  owners: [AccountProject!] @derivedFrom(field: "project")
  createdAt: BigInt!
  updatedAt: BigInt!
  scriptUpdatedAt: BigInt
  contract: Contract!
}

type Contract @entity {
  id: ID!
  admin: Bytes!
  artblocksAddress: Bytes!
  artblocksPercentage: BigInt!
  mintWhitelisted: [Bytes!]!
  randomizerContract: Bytes
  nextProjectId: BigInt!
  projects: [Project!] @derivedFrom(field: "contract")
  whitelisted: [Whitelisting!] @derivedFrom(field: "contract")
}

type Whitelisting @entity {
  id: ID!
  account: Account!
  contract: Contract!
}

type Account @entity {
  id: ID!
  tokens: [Token!] @derivedFrom(field: "owner")
  "Projects the account owns tokens from"
  projectsOwned: [AccountProject!] @derivedFrom(field: "account")
  projectsCreated: [Project!] @derivedFrom(field: "artist")
  whitelistedOn: [Whitelisting!] @derivedFrom(field: "account")
}

type AccountProject @entity {
  id: ID!
  account: Account!
  project: Project!
  count: Int!
}

type Token @entity {
  id: ID!
  invocation: BigInt!
  hash: Bytes!
  owner: Account!
  project: Project!
  uri: String
  osSalesHistory: [OSSaleEntry!]! @derivedFrom(field: "token")
  createdAt: BigInt!
  updatedAt: BigInt!
  transactionHash: Bytes!
}

type OSSaleWrapper @entity {
  id: ID!

  timestamp: BigInt!
  from: Bytes!
  to: Bytes!
  priceInWei: BigInt
  isBundle: Boolean!

  associatedProjectsIds: [ID!] # Field used to keep track of all projects involved in the sale (in case of bundle)
  osSaleEntries: [OSSaleEntry!]! @derivedFrom(field: "osSaleWrapper")
}

type OSSaleEntry @entity {
  id: ID!
  token: Token!
  osSaleWrapper: OSSaleWrapper!
}
