type Project @entity {
  "Unique identifier made up of contract address and project id"
  id: ID!

  "ID of the project on the contract"
  projectId: BigInt!

  "Determines if the project should be visible to the public"
  active: Boolean!

  "Address to split sales with the artist"
  additionalPayee: Bytes

  "Percentage of sales that goes to additional payee"
  additionalPayeePercentage: BigInt

  "Artist that created the project"
  artist: Account!

  "Wallet address of the artist"
  artistAddress: Bytes!

  "Artist name"
  artistName: String

  baseIpfsUri: String
  baseUri: String

  "A project is complete when it has reached its maximum invocations"
  complete: Boolean!

  "Curated, playground, factory. A project with no curation status is considered factory"
  curationStatus: String

  "ERC-20 contract address if the project is purchasable via ERC-20"
  currencyAddress: Bytes

  "Currency symbol for ERC-20"
  currencySymbol: String

  "Artist description of the project"
  description: String

  "Is the project dynamic or a static image"
  dynamic: Boolean!

  "Number of times the project has been invoked - number of tokens of the project"
  invocations: BigInt!

  ipfsHash: String

  "License for the project"
  license: String

  "Once the project is locked its script may never be updated again"
  locked: Boolean!

  "Maximum number of invocations allowed for the project"
  maxInvocations: BigInt!

  "Project name"
  name: String

  "Purchases paused"
  paused: Boolean!

  pricePerTokenInWei: BigInt!

  "Artist/additional payee royalty percentage"
  royaltyPercentage: BigInt

  "The full script composed of scripts"
  script: String

  "Parts of the project script"
  scripts: [ProjectScript!] @derivedFrom(field: "project")

  "The number of scripts stored on-chain"
  scriptCount: BigInt!

  "Extra information about the script and rendering options"
  scriptJSON: String

  "Tokens of the project"
  tokens: [Token!] @derivedFrom(field: "project")

  "Does the project actually use the hash string"
  useHashString: Boolean!

  "Does the project use media from ipfs"
  useIpfs: Boolean

  "Artist or project website"
  website: String

  "Accounts that own tokens of the project"
  owners: [AccountProject!] @derivedFrom(field: "project")

  createdAt: BigInt!
  updatedAt: BigInt!
  activatedAt: BigInt
  scriptUpdatedAt: BigInt
  contract: Contract!

  "Minter configuration for this project (not implemented prior to minter filters)"
  minterConfiguration: ProjectMinterConfiguration

  "Lookup table to get the OpenSea Sale history of the project"
  openSeaSaleLookupTables: [OpenSeaSaleLookupTable!]!
    @derivedFrom(field: "project")
}

type ProjectScript @entity {
  id: ID!
  index: BigInt!
  project: Project!
  script: String!
}

type Contract @entity {
  id: ID!
  admin: Bytes!

  "Address that receives platform fees"
  renderProviderAddress: Bytes!

  "Percentage of sales the platform takes"
  renderProviderPercentage: BigInt!

  "List of contracts that are allowed to mint"
  mintWhitelisted: [Bytes!]!

  "Randomizer contract used to generate token hashes"
  randomizerContract: Bytes

  nextProjectId: BigInt!

  "List of projects on the contract"
  projects: [Project!] @derivedFrom(field: "contract")

  "List of tokens on the contract"
  tokens: [Token!] @derivedFrom(field: "contract")

  "Accounts whitelisted on the contract"
  whitelisted: [Whitelisting!] @derivedFrom(field: "contract")

  createdAt: BigInt!

  updatedAt: BigInt!

  "Associated minter filter (if applicable)"
  minterFilter: MinterFilter
}

type Whitelisting @entity {
  id: ID!
  account: Account!
  contract: Contract!
}

type Account @entity {
  id: ID!
  tokens: [Token!] @derivedFrom(field: "owner")

  "Projects the account owns tokens from"
  projectsOwned: [AccountProject!] @derivedFrom(field: "account")

  "Projects the account is listed as artist for"
  projectsCreated: [Project!] @derivedFrom(field: "artist")

  "Contracts the account is whitelisted on"
  whitelistedOn: [Whitelisting!] @derivedFrom(field: "account")
}

type AccountProject @entity {
  id: ID!
  account: Account!
  project: Project!
  count: Int!
}

type Token @entity {
  "Unique identifier made up of contract address and token id"
  id: ID!

  "ID of the token on the contract"
  tokenId: BigInt!

  "Contract the token is on"
  contract: Contract!

  "Invocation number of the project"
  invocation: BigInt!

  "Unique string used as input to the tokens project script"
  hash: Bytes!

  "Current owner of the token"
  owner: Account!

  "Project of the token"
  project: Project!

  uri: String
  createdAt: BigInt!
  updatedAt: BigInt!

  "Transaction hash of token mint"
  transactionHash: Bytes!

  "Lookup table to get the OpenSea Sale history"
  openSeaSaleLookupTables: [OpenSeaSaleLookupTable!]!
    @derivedFrom(field: "token")
}

type MinterFilter @entity {
  "Unique identifier made up of minter filter contract address"
  id: ID!

  "Associated core contract"
  contract: Contract!

  "Minters allowlisted on MinterFilter"
  minterAllowlist: [Minter!]!

  updatedAt: BigInt!
}

enum MinterType {
  GenArt721FilteredMinter
  GenArt721FilteredMinterETH
  GenArt721FilteredMinterETHAuction
}

type Minter @entity {
  "Unique identifier made up of minter contract address"
  id: ID!

  "Minter type"
  type: MinterType!

  "Associated Minter Filter"
  minterFilter: MinterFilter!

  "Minimum auction length in seconds (for Dutch auction types)"
  minimumAuctionLengthInSeconds: BigInt
}

type ProjectMinterConfiguration @entity {
  "Unique identifier made up of minter contract address-projectId"
  id: ID!

  "The associated project"
  project: Project!

  "The associated minter"
  minter: Minter!

  "true if project's token price has been configured on minter"
  priceIsConfigured: Bool!

  "currency symbol as defined on minter - ETH reserved for ether"
  currencySymbol: String!

  "currency address as defined on minter - address(0) reserved for ether"
  currencyAddress: Bytes!

  "Defines if purchasing token to another is allowed"
  purchaseToDisabled: Boolean!

  "price of token or resting price of Duch auction, in wei"
  basePrice: BigInt

  "Dutch auction start price, in wei"
  startPrice: BigInt

  "Dutch auction start time (unix timestamp)"
  startTime: BigInt

  "Dutch auction end time (unix timestamp)"
  endTime: BigInt
}

enum SaleType {
  Single,
  Bundle
}

type OpenSeaSale @entity {
  "The transaction hash when the OpenSea sale occured"
  id: ID!

  "The sale type (Single | Bundle)"
  saleType: SaleType

  "The block number of the OpenSea sale"
  blockNumber: BigInt!

  "The timestamp of the OpenSea sale"
  blockTimestamp: BigInt!

  "A raw formated string of the token(s) sold (i.e TokenID1::TokenID2::TokenID3)"
  summaryTokensSold: String!

  "Lookup table to get the list of Tokens sold in this sale"
  openSeaSaleLookupTables: [OpenSeaSaleLookupTable!]! @derivedFrom(field: "openSeaSale")

  "The seller address"
  seller: Bytes!

  "The buyer address"
  buyer: Bytes!

  "The ERC20 token used for the payement"
  paymentToken: Bytes!

  "The price of the OpenSea sale"
  price: BigInt!

  "Private sales are flagged by this boolean"
  isPrivate: Boolean!
}

type OpenSeaSaleLookupTable @entity {
  "Set to `Project Id::Token Id::OpenSeaSale Id"
  id: ID!

  "The block number of the sale"
  blockNumber: BigInt!

  "Timestamp of the sale"
  timestamp: BigInt!

  "The associated project"
  project: Project!

  "The token sold"
  token: Token!

  "The associated OpenSea sale"
  openSeaSale: OpenSeaSale!
}