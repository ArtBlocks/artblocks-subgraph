export const meridianScript = "let line_weight = 2;\nlet increment = 0.001;\nlet radial_steps = 512;\nlet mass_lower = 600.0;\nlet mass_upper = 1200.0;\nlet aper_lower = 100.0;\nlet aper_upper = 400.0;\nlet forc_lower = 550.0;\nlet forc_upper = 2250.0;\nlet turb_lower = 0.001;\nlet turb_upper = 1.000;\nlet chao_lower = 0.001;\nlet chao_upper = 0.002;\nlet deta_lower = 4.0;\nlet deta_upper = 10.0;\n\nlet data = [];\n\nlet buffer_size = 2400;\n\nlet res_multi = 0.0;\n\nlet line_color = 0;\n\nlet canvas;\nlet osb;\nlet context;\nlet noise;\nlet features;\n\nfunction remap(n, start1, stop1, start2, stop2) {\n     return ((n - start1) / (stop1 - start1)) * (stop2 - start2) + start2;\n}\n\nfunction evaluate(n, metadata) {\n     let meta = {\n          'description': \"\",\n          'prob': 0\n     }\n\n     let points = {\n          'form': 0,\n          'rare': 0\n     }\n\n     if (n == 1.0) {\n          meta.desciption = \"absolute\";\n          points.rare = 2;\n          points.form = 7;\n          meta.prob = 0.001;\n     } else if (n == 0.0) {\n          meta.desciption = \"void\";\n          points.rare = 2;\n          points.form = 7;\n          meta.prob = 0.001;\n     } else if (n <= 0.01) {\n          meta.desciption = \"minimal\";\n          points.rare = 1;\n          points.form = 5;\n          meta.prob = 0.01;\n     } else if (n > 0.01 && n < 0.1) {\n          meta.desciption = \"marginal\";\n          points.form = 3;\n          meta.prob = 0.09;\n     } else if (n > 0.1 && n < 0.25) {\n          meta.desciption = \"low\";\n          points.form = 1;\n          meta.prob = 0.15;\n     } else if (n > 0.99) {\n          meta.desciption = \"extreme\";\n          points.rare = 1;\n          points.form = 5;\n          meta.prob = 0.01;\n     } else if (n < 0.99 && n > 0.9) {\n          meta.desciption = \"super\";\n          points.form = 3;\n          meta.prob = 0.09;\n     } else if (n < 0.90 && n > 0.75) {\n          meta.desciption = \"high\";\n          points.form = 1;\n          meta.prob = 0.15;\n     } else {\n          meta.desciption = \"average\";\n          meta.prob = 0.5;\n     }\n\n     return metadata ? meta : points;\n}\n\nfunction generate_artblocks_metadata(formdata) {\n     let meta_mass = evaluate(formdata.mass, true);\n     let meta_force = evaluate(formdata.force, true);\n     let meta_symmetry = evaluate(formdata.symmetry, true);\n     let meta_turbulence = evaluate(formdata.turbulence, true);\n     let meta_chaos = evaluate(formdata.chaos, true);\n\n     let prob = meta_mass.prob * meta_force.prob * meta_symmetry.prob * meta_turbulence.prob * meta_chaos.prob;\n\n     let massstr = (\"Mass: \" + (formdata.mass * 100).toFixed(1) + \"%\") + \" [\" + meta_mass.desciption.toUpperCase() + \"]\";\n     let forcestr = (\"Force: \" + (formdata.force * 100).toFixed(1) + \"%\") + \" [\" + meta_force.desciption.toUpperCase() + \"]\";\n     let symstr = (\"Symmetry: \" + (formdata.symmetry * 100).toFixed(1) + \"%\") + \" [\" + meta_symmetry.desciption.toUpperCase() + \"]\";\n     let turbstr = (\"Turbulence: \" + (formdata.turbulence * 100).toFixed(1) + \"%\") + \" [\" + meta_turbulence.desciption.toUpperCase() + \"]\";\n     let chaosstr = (\"Chaos: \" + (formdata.chaos * 100).toFixed(1) + \"%\") + \" [\" + meta_chaos.desciption.toUpperCase() + \"]\";\n     let prostr = \"Chance: 1 in \" + Math.trunc((1.0 / (prob)));\n\n     return [massstr, forcestr, symstr, turbstr, chaosstr, prostr];\n}\n\n\nconst lerp_colour = function(a, b, amount) {\n     const ar = a >> 16,\n          ag = a >> 8 & 0xff,\n          ab = a & 0xff,\n\n          br = b >> 16,\n          bg = b >> 8 & 0xff,\n          bb = b & 0xff,\n\n          rr = ar + amount * (br - ar),\n          rg = ag + amount * (bg - ag),\n          rb = ab + amount * (bb - ab);\n\n     return (rr << 16) + (rg << 8) + (rb | 0);\n};\n\nfunction three_point_gradient(x, start, mid, end) {\n     return (x < 0.5) ? lerp_colour(start, mid, remap(x, 0.0, 0.5, 0.0, 1.0)) :\n          lerp_colour(mid, end, remap(x, 0.5, 1.0, 0.0, 1.0));\n}\n\nfunction sq(number) {\n     return Math.pow(number, 2);\n}\n\nfunction lerp(start, end, amt) {\n     return (1 - amt) * start + amt * end;\n}\n\nfunction process_formdata(hashdata) {\n     let idx_mass = 1;\n     let idx_aperture = 2;\n     let idx_force = 3;\n     let idx_symmetry = 4;\n     let idx_turbulence = 5;\n     let idx_chaos = 6;\n     let idx_saturation = 7;\n     let idx_detail = 8;\n\n     let formdata = {\n          'mass': hashdata[idx_mass],\n          'aperture': hashdata[idx_aperture],\n          'force': hashdata[idx_force],\n          'symmetry': hashdata[idx_symmetry],\n          'turbulence': hashdata[idx_turbulence],\n          'chaos': hashdata[idx_chaos],\n          'saturation': hashdata[idx_saturation],\n          'detail': hashdata[idx_detail]\n     };\n\n     return formdata;\n}\n\nfunction evaluate_points(fd) {\n     let points_mass = evaluate(fd.mass, false);\n     let points_force = evaluate(fd.force, false);\n     let points_symmetry = evaluate(fd.symmetry, false);\n     let points_turbulence = evaluate(fd.turbulence, false);\n     let points_chaos = evaluate(fd.chaos, false);\n\n     let points = {\n          'form': points_mass.form +\n               points_force.form +\n               points_symmetry.form +\n               points_turbulence.form +\n               points_chaos.form,\n\n          'rare': points_mass.rare +\n               points_force.rare +\n               points_symmetry.rare +\n               points_turbulence.rare +\n               points_chaos.rare\n     };\n\n     return points;\n}\n\nfunction generate_renderdata(fd) {\n     let points = evaluate_points(fd);\n\n     let renderdata = {\n          'mass': lerp(mass_lower, mass_upper, fd.mass),\n          'aperture': lerp(aper_lower, aper_upper, fd.aperture),\n          'force': lerp(forc_lower, forc_upper, fd.force),\n          'symmetry': 1.0 - fd.symmetry,\n          'turbulence': lerp(turb_lower, turb_upper, fd.turbulence),\n          'chaos': lerp(chao_lower, chao_upper, fd.chaos),\n          'saturation': fd.saturation,\n          'form_points': points.form,\n          'rare_points': points.rare,\n          'detail': lerp(deta_lower, deta_upper, fd.detail)\n     };\n\n     return renderdata;\n}\n\nfunction process_hash(txn) {\n     let hash_index = 0;\n\n     for (let i = 2; i < 65; i += 2) {\n          let from = i;\n          let to = i + 2;\n          let s = txn.substring(from, to);\n\n          data[hash_index] = parseInt(s, 16) / 255.0;\n\n          hash_index++;\n     }\n\n     return data;\n}\n\nfunction init(txn) {\n\n     let dim = Math.min(window.innerWidth, window.innerHeight)\n\n     res_multi = dim / buffer_size;\n\n     canvas = document.querySelector(\"canvas\");\n     can_context = canvas.getContext(\"2d\");\n\n     can_context.imageSmoothingEnabled = true;\n     can_context.imageSmoothingQuality = \"high\";\n\n     canvas.width = dim;\n     canvas.height = dim;\n\n     can_context.fillStyle = '#000000';\n     can_context.fillRect(0, 0, dim, dim);\n     can_context.lineWidth = line_weight * res_multi;\n\n     line_color = 0xfffad7;\n\n     let hashdata = process_hash(txn);\n\n     let formdata = process_formdata(hashdata);\n\n     let renderdata = generate_renderdata(formdata);\n\n     render(renderdata);\n\n     let ab_metadata = generate_artblocks_metadata(formdata);\n\n     return ab_metadata;\n}\n\nfunction render(rd) {\n     noise = new Noise().noiseDetail(rd.detail);\n     noise.noiseSeed(4);\n\n     for (let i = 0; i < rd.mass; i++) {\n          let norm_inc = sq(i / rd.mass);\n          let ring_rad = rd.aperture + (i * increment);\n          let current_force = rd.force * norm_inc;\n          let alpha = parseInt((255.0 - ((norm_inc) * 255.0)));\n          let norm_turb = rd.turbulence * norm_inc;\n\n          let g, start, middle, end, sat;\n\n          switch (rd.rare_points) {\n               case 0:\n                    start = 0xffad77;\n                    mid = 0xf91362;\n                    end = 0x35126a;\n                    break;\n               case 1:\n                    start = 0xcffff0;\n                    mid = 0x6096db;\n                    end = 0x20fbbc;\n                    break;\n               case 2:\n                    start = 0x73d055;\n                    mid = 0x1f968B;\n                    end = 0x440154;\n                    break;\n               default:\n                    start = 0x12d6df;\n                    mid = 0xb9ffad;\n                    end = 0xf70fff;\n                    break;\n          }\n\n          g = three_point_gradient(norm_inc, start, mid, end);\n\n          if (rd.form_points == 0) {\n               sat = 0.0;\n          } else if (rd.form_points > 0 && rd.form_points < 7) {\n               sat = lerp(0.0, 0.25, rd.saturation);\n          } else if (rd.form_points >= 7 && rd.form_points < 9) {\n               sat = lerp(0.2, 0.75, rd.saturation);\n          } else if (rd.form_points >= 9 && rd.form_points < 10) {\n               sat = lerp(0.75, 0.9, rd.saturation);\n          } else if (rd.form_points >= 10 && rd.form_points < 11) {\n               sat = lerp(0.9, 1.0, rd.saturation);\n          } else {\n               sat = 1.0;\n          }\n\n          let col = lerp_colour(line_color, g, sat);\n\n          let ang = (Math.PI * 2.0) / radial_steps;\n\n          can_context.beginPath();\n\n          for (let j = 0; j <= radial_steps; j++) {\n               let theta = ang * j;\n               let ct = Math.cos(theta);\n               let st = Math.sin(theta);\n               let sample_x = ct + rd.symmetry;\n               let sample_y = st + rd.symmetry;\n               let ken = get_noise(norm_turb * sample_x, norm_turb * sample_y, (i * rd.chaos));\n               let current_aperture = ring_rad + ken * current_force;\n               let x = (canvas.width / 2) + ((current_aperture * ct) * res_multi);\n               let y = (canvas.height / 2) + ((current_aperture * st) * res_multi);\n\n               can_context.lineTo(x, y);\n          }\n\n          can_context.strokeStyle = '#' + col.toString(16) + alpha.toString(16);\n          can_context.stroke();\n\n     }\n}\n\nfunction get_noise(x, y, z) {\n     var v = noise.get(x, y, z);\n\n     return v;\n}\n\n/*\n  Rune Madsen's Noise\n  https://github.com/runemadsen/rune.noise.js/blob/master/src/noise.js\n*/\n\nvar PERLIN_YWRAPB = 4;\nvar PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nvar PERLIN_ZWRAPB = 8;\nvar PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nvar PERLIN_SIZE = 4095;\n\nvar SINCOS_PRECISION = 0.5;\nvar SINCOS_LENGTH = Math.floor(360 / SINCOS_PRECISION);\nvar sinLUT = new Array(SINCOS_LENGTH);\nvar cosLUT = new Array(SINCOS_LENGTH);\nvar DEG_TO_RAD = Math.PI / 180.0;\n\nfor (var i = 0; i < SINCOS_LENGTH; i++) {\n     sinLUT[i] = Math.sin(i * DEG_TO_RAD * SINCOS_PRECISION);\n     cosLUT[i] = Math.cos(i * DEG_TO_RAD * SINCOS_PRECISION);\n}\n\nvar perlin_PI = SINCOS_LENGTH;\nperlin_PI >>= 1;\n\nvar Noise = function() {\n     this.perlin_octaves = 4;\n     this.perlin_amp_falloff = 0.5;\n     this.perlin = null;\n}\n\nNoise.prototype = {\n\n     noiseDetail: function(lod, falloff) {\n          if (lod > 0) {\n               this.perlin_octaves = lod;\n          }\n          if (falloff > 0) {\n               this.perlin_amp_falloff = falloff;\n          }\n          return this;\n     },\n\n     noiseSeed: function(seed) {\n          var lcg = (function() {\n               var m = 4294967296,\n                    a = 1664525,\n                    c = 1013904223,\n                    seed, z;\n               return {\n                    setSeed: function(val) {\n                         z = seed = (val == null ? Math.random() * m : val) >>> 0;\n                    },\n                    getSeed: function() {\n                         return seed;\n                    },\n                    rand: function() {\n                         z = (a * z + c) % m;\n                         return z / m;\n                    }\n               };\n          }());\n\n          lcg.setSeed(seed);\n          this.perlin = new Array(PERLIN_SIZE + 1);\n          for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n               this.perlin[i] = lcg.rand();\n          }\n          return this;\n     },\n\n     get: function(x, y, z) {\n\n          y = y || 0;\n          z = z || 0;\n\n          if (this.perlin == null) {\n               this.perlin = new Array(PERLIN_SIZE + 1);\n               for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n                    this.perlin[i] = Math.random();\n               }\n          }\n\n          if (x < 0) {\n               x = -x;\n          }\n          if (y < 0) {\n               y = -y;\n          }\n          if (z < 0) {\n               z = -z;\n          }\n\n          var xi = Math.floor(x),\n               yi = Math.floor(y),\n               zi = Math.floor(z);\n          var xf = x - xi;\n          var yf = y - yi;\n          var zf = z - zi;\n          var rxf, ryf;\n\n          var r = 0;\n          var ampl = 0.5;\n\n          var n1, n2, n3;\n\n          var noise_fsc = function(i) {\n               return 0.5 * (1.0 - cosLUT[Math.floor(i * perlin_PI) % SINCOS_LENGTH]);\n          };\n\n          for (var o = 0; o < this.perlin_octaves; o++) {\n               var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n               rxf = noise_fsc(xf);\n               ryf = noise_fsc(yf);\n\n               n1 = this.perlin[ of & PERLIN_SIZE];\n               n1 += rxf * (this.perlin[( of +1) & PERLIN_SIZE] - n1);\n               n2 = this.perlin[( of +PERLIN_YWRAP) & PERLIN_SIZE];\n               n2 += rxf * (this.perlin[( of +PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n               n1 += ryf * (n2 - n1);\n\n               of += PERLIN_ZWRAP;\n               n2 = this.perlin[ of & PERLIN_SIZE];\n               n2 += rxf * (this.perlin[( of +1) & PERLIN_SIZE] - n2);\n               n3 = this.perlin[( of +PERLIN_YWRAP) & PERLIN_SIZE];\n               n3 += rxf * (this.perlin[( of +PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n               n2 += ryf * (n3 - n2);\n\n               n1 += noise_fsc(zf) * (n2 - n1);\n\n               r += n1 * ampl;\n               ampl *= this.perlin_amp_falloff;\n               xi <<= 1;\n               xf *= 2;\n               yi <<= 1;\n               yf *= 2;\n               zi <<= 1;\n               zf *= 2;\n\n               if (xf >= 1.0) {\n                    xi++;\n                    xf--;\n               }\n               if (yf >= 1.0) {\n                    yi++;\n                    yf--;\n               }\n               if (zf >= 1.0) {\n                    zi++;\n"